{"body":"CompositionTests\r\n====\r\n\r\nUses ApprovalTests and MEFX to provide a simple interface for executing MEF Composition tests.\r\n\r\nWhat can it be used for?\r\n---\r\n\r\nWhen you know what your composition should look like, you can create automated integration tests that lock down the composition.\r\n\r\nExamples\r\n---\r\n\r\nSay you have an attributed MEF part:\r\n\r\n    [Export(typeof(Car))]\r\n    public class Ford : Car\r\n\r\nYou could use the MEFX Command Line tool to examine the type and you would expect output like this:\r\n\r\n    [Part] CarDealership.Ford from: TypeCatalog (Types='CarDealership.Ford').\r\n      [Export] CarDealership.Ford (ContractName=\"CarDealership.Car\")\r\n\t\r\nLet's assume that this is correct, and that someday down the line a junior programmer decides there should be an `ICar` interface and changes your export to this:\r\n\r\n    [Export(typeof(ICar))]\r\n    public class Ford : Car, ICar\r\n\r\nNow MEF can't satisfy any `Car` imports you might have.  MEFX can catch this type of breakage (and much more) but you have to run it yourself.  Wouldn't it be nice to run an automated check that would catch this scenario? `CompositionTests` exists to fill that gap:\r\n\r\n    using ApprovalTests.Reporters;\r\n    using CompositionTests;\r\n\r\n    [TestClass]\r\n    [UseReporter(typeof(DiffReporter))]\r\n    public class IntegrationTest\r\n    {\r\n        [TestMethod]\r\n        public void VerifyComposition()\r\n        {\r\n            var catalog = new TypeCatalog(typeof(Ford));\r\n            MefComposition.VerifyCompositionInfo(catalog);\r\n        }\r\n    }\r\n\r\nThis test will leverage the core library behind MEFX to produce the same output you would see on the command line, then use [ApprovalTests](http://www.approvaltests.com) to process the output and ensure that it doesn't change without your approval.  You can use CompositionTests with 4 of the 5 MEF catalog types (`DeploymentCatalog` is not supported at this time.)  And because we're automating MEFX, the test will not only show you the contents of the catalog, but will perform static analysis on the catalog contents, tell you which parts will be rejected, and idenitify possible rejection root causes.\r\n\r\nLets say our `Ford : Car` needs a motor:\r\n\r\n    [Export(typeof(Car))]\r\n    public class Ford : Car\r\n    {\r\n        [Import]\r\n        public IMotor Motor { get; set; } \r\n\r\nIf our catalog doesn't have motor, our test will let us know:\r\n\r\n    [Part] CarDealership.Ford from: TypeCatalog (Types='CarDealership.Ford').\r\n      [Primary Rejection]\r\n      [Export] CarDealership.Ford (ContractName=\"CarDealership.Car\")\r\n      [Import] CarDealership.Ford.Motor (ContractName=\"CarDealership.IMotor\")\r\n        [Exception] System.ComponentModel.Composition.ImportCardinalityMismatchException: No exports were found that match the constraint: \r\n        ContractName    CarDealership.IMotor\r\n        RequiredTypeIdentity    CarDealership.IMotor\r\n        at System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(ImportDefinition definition, AtomicComposition atomicComposition)\r\n        at System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(ImportDefinition definition)\r\n        at Microsoft.ComponentModel.Composition.Diagnostics.CompositionInfo.AnalyzeImportDefinition(ExportProvider host, IEnumerable`1 availableParts, ImportDefinition id)\r\n\r\nThen we know that we need to add a `Motor` part to satisfy the `Car`\r\n\r\n    [TestMethod]\r\n    public void VerifyComposition()\r\n    {\r\n        var catalog = new TypeCatalog(typeof(Ford), typeof(V8Motor));\r\n        MefComposition.VerifyCompositionInfo(catalog);\r\n    }\r\n\r\nAnd now our composition is happy, we can approve the new output to ensure that no one removes the `IMotor` to make our `Car` unusable.\r\n\r\n    [Part] CarDealership.Ford from: TypeCatalog (Types='CarDealership.Ford, CarDealership.V8Motor').\r\n      [Export] CarDealership.Ford (ContractName=\"CarDealership.Car\")\r\n      [Import] CarDealership.Ford.Motor (ContractName=\"CarDealership.IMotor\")\r\n         [SatisfiedBy] CarDealership.V8Motor (ContractName=\"CarDealership.IMotor\") from: CarDealership.V8Motor from: TypeCatalog (Types='CarDealership.Ford, CarDealership.V8Motor').\r\n\r\n    [Part] CarDealership.V8Motor from: TypeCatalog (Types='CarDealership.Ford, CarDealership.V8Motor').\r\n      [Export] CarDealership.V8Motor (ContractName=\"CarDealership.IMotor\")\r\n\t\r\nBut instead of building your catalog in your test, it would be a better idea to define it in your production code:\r\n\t\r\n    public class Program\r\n    {\r\n        static Program()\r\n        {\r\n            Catalog = new TypeCatalog(typeof(Ford), typeof(V8Motor));\r\n            Host = new CompositionContainer(Catalog);\r\n        }\r\n\r\n        public static TypeCatalog Catalog { get; private set; }\r\n\r\nAnd share that catalog with the test:\r\n\r\n    [TestMethod]\r\n    public void VerifyComposition()\r\n    {\r\n        MefComposition.VerifyCompositionInfo(Program.Catalog);\r\n    }\r\n\r\nBut sometimes MEFX puts extra information into the output that will break your ApprovalTest, even though nothing has actually changed that effects compostion (like version numbers and file paths).  So CompositionTests provides specific methods per catalog that can scrub common problem areas for you:\r\n\r\n    [TestMethod]\r\n    public void VerifyComposition()\r\n    {\r\n        MefComposition.VerifyTypeCatalog(Program.Catalog);\r\n    }\r\n\r\nOr you can define any custom `Func<string, string>` to manipulate the output before it reaches ApprovalTests:\r\n\r\n    [TestMethod]\r\n    public void VerifyComposition()\r\n    {\r\n        MefComposition.VerifyTypeCatalog(Program.Catalog, s => RemoveTypeNames(s));\r\n    }\r\n\r\nIf you need to use an `ExportProvider` other than `CompositionContainer`, you can do that too, just check the overloads of `VerifyCompositionInfo` for one that works for you, and see the test project for more examples.\r\n\r\nMore Info\r\n---\r\n\r\n####Related Blog Posts:\r\n\r\n[Stop Guessing About MEF Composition and Start Testing](http://ihadthisideaonce.com/2012/01/31/stop-guessing-about-mef-composition-and-start-testing/)\r\n\r\n[MEF Composition Tests, Redux](http://ihadthisideaonce.com/2012/06/12/mef-composition-tests-redux/)\r\n\r\n[When is the ExportProvider Interesting?](http://ihadthisideaonce.com/2012/06/26/when-is-the-exportprovider-interesting/)\r\n\r\nAvailable on NuGet\r\n---\r\n\r\n[Install-Package CompositionTests](https://nuget.org/packages/CompositionTests)\r\n\r\nLicense\r\n---\r\n\r\n[MIT License](https://github.com/jamesrcounts/CompositionTests/blob/master/LICENSE.md)\r\n\r\nBuilding the source\r\n---\r\n\r\nWindows\r\n\r\nAfter cloning the repository, run msbuild, or open in Visual Studio and select \"Build Solution\" from the Build menu.\r\n\r\nPublic API\r\n---\r\nSee [ApiTest.ApprovePublicApi.approved.txt](https://github.com/jamesrcounts/CompositionTests/blob/master/CompositionTests.Tests/ApiTest.ApprovePublicApi.approved.txt) in the [CompositionTests.Tests](https://github.com/jamesrcounts/CompositionTests/tree/master/CompositionTests.Tests) directory.\r\n\r\nQuestions?\r\n---\r\n\r\ntwitter: [@jamesrcounts](https://twitter.com/#!/jamesrcounts) or #CompositionTests","tagline":"From \"MEF, WTF!?\" to \"MEF, FTW!\"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"CompositionTests","google":"UA-33029397-1"}